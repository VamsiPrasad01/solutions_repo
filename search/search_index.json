{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection A Comprehensive Physics and Computational Analysis 1. Theoretical Foundation 1.1 Derivation of Projectile Motion Equations We begin with Newton's second law in 2D for a projectile with initial velocity v\u2080 at angle \u03b8 under gravity g : Horizontal Motion (x-axis): No acceleration \u2192 Uniform motion $$ \\frac{d^2x}{dt^2} = 0 \\implies x(t) = v_{0x}t = \\color{#E74C3C}{v_0\\cos\\theta} \\cdot t $$ Vertical Motion (y-axis): Constant acceleration (-g) $$ \\frac{d^2y}{dt^2} = -g \\implies y(t) = \\color{#E74C3C}{v_0\\sin\\theta}\\cdot t - \\frac{1}{2}\\color{#E74C3C}{g}t^2 $$ 1.2 Time of Flight and Range Solving for when the projectile returns to ground (y=0): $$ T = \\frac{2\\color{#E74C3C}{v_0\\sin\\theta}}{\\color{#E74C3C}{g}} $$ Substituting into \\( x(t) \\) gives the range equation : $$ R = \\frac{\\color{#E74C3C}{v_0^2}\\sin(2\\theta)}{\\color{#E74C3C}{g}} \\quad \\text{(Maximum at \u03b8=45\u00b0)} $$ 1.3 Family of Solutions The general solution forms a parameterized family based on: - Initial velocity (v\u2080) - Launch angle (\u03b8) - Gravity (g) - Initial height (h\u2080) 2. Range Analysis 2.1 Angle Dependence Key characteristics of the range equation: - Peak range at \u03b8=45\u00b0 (when sin(2\u03b8)=1) - Complementary angles (e.g., 30\u00b0 & 60\u00b0) give equal ranges - Zero range at \u03b8=0\u00b0 and \u03b8=90\u00b0 2.2 Parameter Sensitivity Analysis Parameter Effect Mathematical Relationship v\u2080 Quadratic impact \\( R \\propto v_0^2 \\) g Inverse relationship \\( R \\propto \\frac{1}{g} \\) h\u2080 Increases range Modified equation required 3. Practical Applications 3.1 Real-World Modifications Scenario Effect on Projectile Uphill Launch Optimal angle >45\u00b0 Downhill Launch Optimal angle <45\u00b0 Air Resistance Reduces range by 30-50%, optimal angle ~40\u00b0 Spin (Magnus Effect) Creates curved trajectories 4. Computational Implementation 4.1 Python Simulation Code Click to see the Python simulation code import numpy as np import matplotlib.pyplot as plt from ipywidgets import interact def plot_trajectory(v0=20, theta=45, g=9.81, h0=0): theta_rad = np.radians(theta) t_flight = (v0*np.sin(theta_rad) + np.sqrt((v0*np.sin(theta_rad))**2 + 2*g*h0))/g t = np.linspace(0, t_flight, 100) x = v0*np.cos(theta_rad)*t y = h0 + v0*np.sin(theta_rad)*t - 0.5*g*t**2 plt.figure(figsize=(10,5)) plt.plot(x, y, 'b-', linewidth=2) plt.title(f'Projectile Trajectory (\u03b8={theta}\u00b0, v\u2080={v0}m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.grid() plt.ylim(0, max(y)*1.2) interact(plot_trajectory, v0=(5,50,5), theta=(0,90,5), g=(1.62,24.79,0.1), h0=(0,20,1)) 4.2 Key Visualizations Range vs Angle Curves The graph illustrates the relationship between the launch angle (\u03b8) and the resulting range (R) of a projectile in the absence of air resistance. It shows a parabolic pattern, peaking at 45\u00b0, where the range is maximized. Complementary angles (like 30\u00b0 and 60\u00b0) produce identical ranges, highlighting the symmetry of projectile motion. The absence of air resistance simplifies the motion, ensuring that only gravity influences the projectile's path. Trajectories for Different Launch Angles This diagram depicts the trajectories of a projectile launched at different angles\u201430\u00b0, 45\u00b0, 60\u00b0, and 75\u00b0. The optimal range occurs at a launch angle of 45\u00b0, where the balance between horizontal and vertical components of velocity is ideal. As the angle increases beyond 45\u00b0, the height increases, but the horizontal range decreases. This visualization demonstrates the compromise between height and distance in projectile motion. 5. Deliverables 5.1 Complete Analysis Package Jupyter Notebook with: Interactive trajectory simulator Parameter sensitivity plots Planetary environment comparisons 5.2 Limitations and Extensions Current Limitations: - No air resistance - Flat Earth assumption - 2D-only simulation Advanced Extensions: 1. Drag Force Model $$ F_{\\text{drag}} = -\\frac{1}{2}C_d\\rho A v^2 $$ 2. Wind Effects - Crosswind compensation 3. 3D Simulation - Coriolis effect for long-range projectiles Conclusion: This investigation bridges fundamental physics with practical applications through computational modeling. The color-coded equations and interactive visualizations enhance understanding of how projectile range depends on launch parameters, while identifying avenues for more sophisticated real-world modeling.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"A Comprehensive Physics and Computational Analysis","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-derivation-of-projectile-motion-equations","text":"We begin with Newton's second law in 2D for a projectile with initial velocity v\u2080 at angle \u03b8 under gravity g : Horizontal Motion (x-axis): No acceleration \u2192 Uniform motion $$ \\frac{d^2x}{dt^2} = 0 \\implies x(t) = v_{0x}t = \\color{#E74C3C}{v_0\\cos\\theta} \\cdot t $$ Vertical Motion (y-axis): Constant acceleration (-g) $$ \\frac{d^2y}{dt^2} = -g \\implies y(t) = \\color{#E74C3C}{v_0\\sin\\theta}\\cdot t - \\frac{1}{2}\\color{#E74C3C}{g}t^2 $$","title":"1.1 Derivation of Projectile Motion Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight-and-range","text":"Solving for when the projectile returns to ground (y=0): $$ T = \\frac{2\\color{#E74C3C}{v_0\\sin\\theta}}{\\color{#E74C3C}{g}} $$ Substituting into \\( x(t) \\) gives the range equation : $$ R = \\frac{\\color{#E74C3C}{v_0^2}\\sin(2\\theta)}{\\color{#E74C3C}{g}} \\quad \\text{(Maximum at \u03b8=45\u00b0)} $$","title":"1.2 Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-family-of-solutions","text":"The general solution forms a parameterized family based on: - Initial velocity (v\u2080) - Launch angle (\u03b8) - Gravity (g) - Initial height (h\u2080)","title":"1.3 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis","text":"","title":"2. Range Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-angle-dependence","text":"Key characteristics of the range equation: - Peak range at \u03b8=45\u00b0 (when sin(2\u03b8)=1) - Complementary angles (e.g., 30\u00b0 & 60\u00b0) give equal ranges - Zero range at \u03b8=0\u00b0 and \u03b8=90\u00b0","title":"2.1 Angle Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-parameter-sensitivity-analysis","text":"Parameter Effect Mathematical Relationship v\u2080 Quadratic impact \\( R \\propto v_0^2 \\) g Inverse relationship \\( R \\propto \\frac{1}{g} \\) h\u2080 Increases range Modified equation required","title":"2.2 Parameter Sensitivity Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-real-world-modifications","text":"Scenario Effect on Projectile Uphill Launch Optimal angle >45\u00b0 Downhill Launch Optimal angle <45\u00b0 Air Resistance Reduces range by 30-50%, optimal angle ~40\u00b0 Spin (Magnus Effect) Creates curved trajectories","title":"3.1 Real-World Modifications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-computational-implementation","text":"","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#41-python-simulation-code","text":"Click to see the Python simulation code import numpy as np import matplotlib.pyplot as plt from ipywidgets import interact def plot_trajectory(v0=20, theta=45, g=9.81, h0=0): theta_rad = np.radians(theta) t_flight = (v0*np.sin(theta_rad) + np.sqrt((v0*np.sin(theta_rad))**2 + 2*g*h0))/g t = np.linspace(0, t_flight, 100) x = v0*np.cos(theta_rad)*t y = h0 + v0*np.sin(theta_rad)*t - 0.5*g*t**2 plt.figure(figsize=(10,5)) plt.plot(x, y, 'b-', linewidth=2) plt.title(f'Projectile Trajectory (\u03b8={theta}\u00b0, v\u2080={v0}m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.grid() plt.ylim(0, max(y)*1.2) interact(plot_trajectory, v0=(5,50,5), theta=(0,90,5), g=(1.62,24.79,0.1), h0=(0,20,1))","title":"4.1 Python Simulation Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#42-key-visualizations","text":"Range vs Angle Curves The graph illustrates the relationship between the launch angle (\u03b8) and the resulting range (R) of a projectile in the absence of air resistance. It shows a parabolic pattern, peaking at 45\u00b0, where the range is maximized. Complementary angles (like 30\u00b0 and 60\u00b0) produce identical ranges, highlighting the symmetry of projectile motion. The absence of air resistance simplifies the motion, ensuring that only gravity influences the projectile's path. Trajectories for Different Launch Angles This diagram depicts the trajectories of a projectile launched at different angles\u201430\u00b0, 45\u00b0, 60\u00b0, and 75\u00b0. The optimal range occurs at a launch angle of 45\u00b0, where the balance between horizontal and vertical components of velocity is ideal. As the angle increases beyond 45\u00b0, the height increases, but the horizontal range decreases. This visualization demonstrates the compromise between height and distance in projectile motion.","title":"4.2 Key Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-deliverables","text":"","title":"5. Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#51-complete-analysis-package","text":"Jupyter Notebook with: Interactive trajectory simulator Parameter sensitivity plots Planetary environment comparisons","title":"5.1 Complete Analysis Package"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#52-limitations-and-extensions","text":"Current Limitations: - No air resistance - Flat Earth assumption - 2D-only simulation Advanced Extensions: 1. Drag Force Model $$ F_{\\text{drag}} = -\\frac{1}{2}C_d\\rho A v^2 $$ 2. Wind Effects - Crosswind compensation 3. 3D Simulation - Coriolis effect for long-range projectiles Conclusion: This investigation bridges fundamental physics with practical applications through computational modeling. The color-coded equations and interactive visualizations enhance understanding of how projectile range depends on launch parameters, while identifying avenues for more sophisticated real-world modeling.","title":"5.2 Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum A Comprehensive Physics and Computational Analysis 1. Theoretical Foundation 1.1 Equation of Motion A forced damped pendulum is governed by a second-order nonlinear differential equation: \\[ \\ddot{\\theta} + \\lambda\\,\\dot{\\theta} + \\omega_0^2 \\sin\\theta = f \\cos(\\Omega t) \\tag{1} \\] Where: - \\( \\omega_0 = \\sqrt{g/L} \\) : natural angular frequency - \\( \\lambda \\) : damping coefficient - \\( f \\) , \\( \\Omega \\) : drive amplitude and frequency For small oscillations, \\( \\sin\\theta \\approx \\theta \\) , and the equation simplifies to: \\[ \\ddot{\\theta} + \\lambda\\,\\dot{\\theta} + \\omega_0^2\\,\\theta = f \\cos(\\Omega t) \\tag{2} \\] This linear equation has an analytically solvable steady-state solution plus a decaying transient. 2. Analytical Behavior 2.1 Small-Angle Solution & Resonance At steady state: \\[ \\theta(t) = A_p \\cos(\\Omega t - \\delta) \\] Where: \\[ A_p(\\Omega) = \\frac{f}{\\sqrt{(\\omega_0^2 - \\Omega^2)^2 + (\\lambda\\,\\Omega)^2}} \\tag{3} \\] Resonance occurs when \\( \\Omega \\approx \\omega_0 \\) At \\( \\lambda = 0 \\) , and \\( \\Omega = \\omega_0 \\) , amplitude grows linearly \u2014 unbounded Resonance pumps energy efficiently into the pendulum, increasing amplitude. 3. Nonlinearity & Chaos 3.1 Beyond the Linear Regime \\( \\sin\\theta \\) dominates \u2192 Nonlinear effects emerge Leads to anharmonic motion, subharmonics, or chaotic behavior Chaos is deterministic yet unpredictable. Sensitive to initial conditions. Notably: - Drive amplitude + low damping = transition to chaos - Adjacent trajectories diverge rapidly in phase space 4. Energy Behavior & Phase Dynamics 4.1 Energy & Resonance in Nonlinear Regimes Even with nonlinearity: - Resonant energy transfer persists - Motion may phase-lock with the driver (oscillate in sync) At high amplitudes: - Secondary resonances - Unpredictable wild swings - Energy oscillates irregularly, yet remains bounded 5. Parameter Sensitivity 5.1 System Response to Parameters Parameter Effect Damping ( \\(\\lambda\\) ) High \u2192 suppress chaos; Low \u2192 allows rich dynamics Drive Amplitude ( \\(f\\) ) Higher \u2192 large rotations, period-doubling Drive Frequency ( \\(\\Omega\\) ) Resonance at \\(\\omega_0\\) ; others \u2192 chaos 6. Bifurcation & Transition to Chaos 6.1 Bifurcation & Poincar\u00e9 Sections As \\(f\\) increases: - Period-1 \u2192 Period-2 \u2192 Period-4 \u2192 Chaos - Other routes: quasi-periodicity , intermittency - Phase space: From closed loops to strange attractors Visualizing motion stroboscopically (Poincar\u00e9 sections) reveals transitions. 7. Physical Interpretation 7.1 Energy Flow and Chaos Periodic motion absorbs energy in a stable way Chaotic motion \u2192 erratic energy exchange Forms strange attractors in phase space with fractal structure 8. Practical Applications 8.1 Real-World Relevance Application Description Vibration Energy Harvesting Uses tuned pendulums to convert ambient energy Suspension Bridges Damping prevents resonant destruction (e.g., Tacoma Narrows) Electrical Circuits RLC and Josephson junctions mimic pendulum dynamics Other Examples Swings, Foucault pendulums, prosthetics, ships 9. Computational Simulation 9.1 Python Implementation Click to view Python Code import numpy as np from math import sin, cos from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g/L) lambda_damp = 0.5 drive_amp = 1.2 drive_freq = 2/3 * omega0 def pendulum_ode(t, y): theta, omega = y return [omega, -lambda_damp*omega - (omega0**2)*sin(theta) + drive_amp*cos(drive_freq*t)] t_span = (0, 100) y0 = [0.1, 0.0] sol = solve_ivp(pendulum_ode, t_span, y0, max_step=0.01, dense_output=True) t = sol.t theta = sol.y[0] omega = sol.y[1] # Plot angle vs time plt.figure() plt.plot(t, theta) plt.title(\"Pendulum angle over time\") plt.xlabel(\"Time t (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.show() # Plot phase portrait plt.figure() plt.plot(theta, omega, '.') plt.title(\"Phase portrait\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.show() We use a drive frequency of \\( \\frac{2}{3}\\omega_0 \\) , known to produce chaotic behavior under strong driving. The simulation outputs: Angle vs. Time Phase Portrait These plots highlight regular and chaotic dynamics, where: - Periodic motion traces closed loops - Chaotic motion creates a dense, non-repeating structure in phase space Poincar Sections Left: Period-2 orbit two alternating points. Right: Chaotic orbit scattered structure. Sampling at drive period intervals visualizes periodicity vs. chaos. Period doubling manifests as increasing points; chaos emerges as irregular clouds. Bifurcation Diagram Drive amplitude vs. Poincar angle \u03b8: Single value splits into two four continuum (chaos). Bifurcation diagrams reveal how changes in forcing amplitude lead to complex oscillatory behavior and chaos, with windows of periodicity embedded within. 10. Model Limitations & Extensions 10.1 Areas for Further Study Nonlinear Damping: Drag/friction modifies dynamics Complex Forcing: Multi-frequency or stochastic inputs Additional DOF: Double pendulums, moving pivots Feedback & Control: Intentional chaos suppression or enhancement Conclusion: This exploration of the forced damped pendulum bridges analytical physics and chaotic nonlinear systems through elegant mathematics and interactive simulation. Matching real-world phenomena with visual and numerical models, the pendulum becomes a lens through which we understand and predict dynamic, complex motion.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"A Comprehensive Physics and Computational Analysis","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-equation-of-motion","text":"A forced damped pendulum is governed by a second-order nonlinear differential equation: \\[ \\ddot{\\theta} + \\lambda\\,\\dot{\\theta} + \\omega_0^2 \\sin\\theta = f \\cos(\\Omega t) \\tag{1} \\] Where: - \\( \\omega_0 = \\sqrt{g/L} \\) : natural angular frequency - \\( \\lambda \\) : damping coefficient - \\( f \\) , \\( \\Omega \\) : drive amplitude and frequency For small oscillations, \\( \\sin\\theta \\approx \\theta \\) , and the equation simplifies to: \\[ \\ddot{\\theta} + \\lambda\\,\\dot{\\theta} + \\omega_0^2\\,\\theta = f \\cos(\\Omega t) \\tag{2} \\] This linear equation has an analytically solvable steady-state solution plus a decaying transient.","title":"1.1 Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analytical-behavior","text":"","title":"2. Analytical Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-small-angle-solution-resonance","text":"At steady state: \\[ \\theta(t) = A_p \\cos(\\Omega t - \\delta) \\] Where: \\[ A_p(\\Omega) = \\frac{f}{\\sqrt{(\\omega_0^2 - \\Omega^2)^2 + (\\lambda\\,\\Omega)^2}} \\tag{3} \\] Resonance occurs when \\( \\Omega \\approx \\omega_0 \\) At \\( \\lambda = 0 \\) , and \\( \\Omega = \\omega_0 \\) , amplitude grows linearly \u2014 unbounded Resonance pumps energy efficiently into the pendulum, increasing amplitude.","title":"2.1 Small-Angle Solution &amp; Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-nonlinearity-chaos","text":"","title":"3. Nonlinearity &amp; Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-beyond-the-linear-regime","text":"\\( \\sin\\theta \\) dominates \u2192 Nonlinear effects emerge Leads to anharmonic motion, subharmonics, or chaotic behavior Chaos is deterministic yet unpredictable. Sensitive to initial conditions. Notably: - Drive amplitude + low damping = transition to chaos - Adjacent trajectories diverge rapidly in phase space","title":"3.1 Beyond the Linear Regime"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-energy-behavior-phase-dynamics","text":"","title":"4. Energy Behavior &amp; Phase Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-energy-resonance-in-nonlinear-regimes","text":"Even with nonlinearity: - Resonant energy transfer persists - Motion may phase-lock with the driver (oscillate in sync) At high amplitudes: - Secondary resonances - Unpredictable wild swings - Energy oscillates irregularly, yet remains bounded","title":"4.1 Energy &amp; Resonance in Nonlinear Regimes"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-parameter-sensitivity","text":"","title":"5. Parameter Sensitivity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-system-response-to-parameters","text":"Parameter Effect Damping ( \\(\\lambda\\) ) High \u2192 suppress chaos; Low \u2192 allows rich dynamics Drive Amplitude ( \\(f\\) ) Higher \u2192 large rotations, period-doubling Drive Frequency ( \\(\\Omega\\) ) Resonance at \\(\\omega_0\\) ; others \u2192 chaos","title":"5.1 System Response to Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-bifurcation-transition-to-chaos","text":"","title":"6. Bifurcation &amp; Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#61-bifurcation-poincare-sections","text":"As \\(f\\) increases: - Period-1 \u2192 Period-2 \u2192 Period-4 \u2192 Chaos - Other routes: quasi-periodicity , intermittency - Phase space: From closed loops to strange attractors Visualizing motion stroboscopically (Poincar\u00e9 sections) reveals transitions.","title":"6.1 Bifurcation &amp; Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-physical-interpretation","text":"","title":"7. Physical Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#71-energy-flow-and-chaos","text":"Periodic motion absorbs energy in a stable way Chaotic motion \u2192 erratic energy exchange Forms strange attractors in phase space with fractal structure","title":"7.1 Energy Flow and Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-practical-applications","text":"","title":"8. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#81-real-world-relevance","text":"Application Description Vibration Energy Harvesting Uses tuned pendulums to convert ambient energy Suspension Bridges Damping prevents resonant destruction (e.g., Tacoma Narrows) Electrical Circuits RLC and Josephson junctions mimic pendulum dynamics Other Examples Swings, Foucault pendulums, prosthetics, ships","title":"8.1 Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#9-computational-simulation","text":"","title":"9. Computational Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#91-python-implementation","text":"Click to view Python Code import numpy as np from math import sin, cos from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 omega0 = np.sqrt(g/L) lambda_damp = 0.5 drive_amp = 1.2 drive_freq = 2/3 * omega0 def pendulum_ode(t, y): theta, omega = y return [omega, -lambda_damp*omega - (omega0**2)*sin(theta) + drive_amp*cos(drive_freq*t)] t_span = (0, 100) y0 = [0.1, 0.0] sol = solve_ivp(pendulum_ode, t_span, y0, max_step=0.01, dense_output=True) t = sol.t theta = sol.y[0] omega = sol.y[1] # Plot angle vs time plt.figure() plt.plot(t, theta) plt.title(\"Pendulum angle over time\") plt.xlabel(\"Time t (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.show() # Plot phase portrait plt.figure() plt.plot(theta, omega, '.') plt.title(\"Phase portrait\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.show() We use a drive frequency of \\( \\frac{2}{3}\\omega_0 \\) , known to produce chaotic behavior under strong driving. The simulation outputs: Angle vs. Time Phase Portrait These plots highlight regular and chaotic dynamics, where: - Periodic motion traces closed loops - Chaotic motion creates a dense, non-repeating structure in phase space","title":"9.1 Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincar-sections","text":"Left: Period-2 orbit two alternating points. Right: Chaotic orbit scattered structure. Sampling at drive period intervals visualizes periodicity vs. chaos. Period doubling manifests as increasing points; chaos emerges as irregular clouds.","title":"Poincar Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram","text":"Drive amplitude vs. Poincar angle \u03b8: Single value splits into two four continuum (chaos). Bifurcation diagrams reveal how changes in forcing amplitude lead to complex oscillatory behavior and chaos, with windows of periodicity embedded within.","title":"Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#10-model-limitations-extensions","text":"","title":"10. Model Limitations &amp; Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#101-areas-for-further-study","text":"Nonlinear Damping: Drag/friction modifies dynamics Complex Forcing: Multi-frequency or stochastic inputs Additional DOF: Double pendulums, moving pivots Feedback & Control: Intentional chaos suppression or enhancement","title":"10.1 Areas for Further Study"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This exploration of the forced damped pendulum bridges analytical physics and chaotic nonlinear systems through elegant mathematics and interactive simulation. Matching real-world phenomena with visual and numerical models, the pendulum becomes a lens through which we understand and predict dynamic, complex motion.","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Investigating the Orbital Period\u2013Radius Relationship Theoretical Foundation Kepler\u2019s Third Law (Circular Orbits) For a satellite in circular orbit around a much larger body (e.g., Earth, Sun), gravitational force provides the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancelling \\(m\\) and rearranging gives the orbital speed: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\tag{1} \\] Squaring both sides: \\[ T^2 \\propto r^3 \\] This is Kepler\u2019s Third Law for circular motion. Implications in Astronomy This law allows determination of mass of celestial objects using orbital characteristics. Used in satellite mission planning and planetary system modeling . For solar system planets, plotting \\(T^2\\) vs \\(r^3\\) yields a straight line . Real-World Examples Earth-Moon System: Moon's orbital radius: \\(384,400\\) km Orbital period: ~27.3 days Solar System: Mercury to Neptune follow \\(T^2 \\propto r^3\\) Deviations arise for highly elliptical orbits or perturbed systems \ud83d\udcca Visual comparison of planetary data : [Insert chart: Log-Log plot of T\u00b2 vs R\u00b3 for Solar System planets] \ud83d\udccc Image placeholder: ??? Simulation: Circular Orbits Let\u2019s simulate satellite motion around a central body and verify Kepler\u2019s Law. Click to view Python code import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(6.7e6, 4.2e7, 100) # Varying orbit radius periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) plt.figure() plt.plot(radii / 1e6, periods / 3600) plt.title(\"Orbital Period vs Radius\") plt.xlabel(\"Orbital Radius (10\u2076 m)\") plt.ylabel(\"Period (hours)\") plt.grid(True) plt.show() \ud83d\udccc Plot placeholder: Orbital Period vs Radius \ud83d\udccc Image: ??? Orbit Animation (Optional) A simple simulation of a satellite orbiting Earth. \ud83d\udccc Animated GIF placeholder: Satellite orbit path simulation \ud83c\udf9e\ufe0f File: ??? Extension to Elliptical Orbits For ellipses, Kepler\u2019s Third Law still holds, but \\(r\\) becomes the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Applies to: - Planetary systems - Comets and asteroids - Exoplanet detection via transit timing Conclusion The \\(T^2 \\propto r^3\\) relationship connects geometry with dynamics Enables mass/distance calculations for celestial objects Holds in ideal and elliptical orbits, proving essential for astrophysics , satellite design , and space exploration Kepler\u2019s Third Law bridges the gap between Newtonian gravity and orbital motion \u2014 an elegant expression of universal harmony.","title":"Investigating the Orbital Period\u2013Radius Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#investigating-the-orbital-periodradius-relationship","text":"","title":"Investigating the Orbital Period\u2013Radius Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-circular-orbits","text":"For a satellite in circular orbit around a much larger body (e.g., Earth, Sun), gravitational force provides the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancelling \\(m\\) and rearranging gives the orbital speed: \\[ v = \\sqrt{\\frac{G M}{r}} \\] The period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\tag{1} \\] Squaring both sides: \\[ T^2 \\propto r^3 \\] This is Kepler\u2019s Third Law for circular motion.","title":"Kepler\u2019s Third Law (Circular Orbits)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"This law allows determination of mass of celestial objects using orbital characteristics. Used in satellite mission planning and planetary system modeling . For solar system planets, plotting \\(T^2\\) vs \\(r^3\\) yields a straight line .","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#earth-moon-system","text":"Moon's orbital radius: \\(384,400\\) km Orbital period: ~27.3 days","title":"Earth-Moon System:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#solar-system","text":"Mercury to Neptune follow \\(T^2 \\propto r^3\\) Deviations arise for highly elliptical orbits or perturbed systems \ud83d\udcca Visual comparison of planetary data : [Insert chart: Log-Log plot of T\u00b2 vs R\u00b3 for Solar System planets] \ud83d\udccc Image placeholder: ???","title":"Solar System:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-circular-orbits","text":"Let\u2019s simulate satellite motion around a central body and verify Kepler\u2019s Law. Click to view Python code import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(6.7e6, 4.2e7, 100) # Varying orbit radius periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) plt.figure() plt.plot(radii / 1e6, periods / 3600) plt.title(\"Orbital Period vs Radius\") plt.xlabel(\"Orbital Radius (10\u2076 m)\") plt.ylabel(\"Period (hours)\") plt.grid(True) plt.show() \ud83d\udccc Plot placeholder: Orbital Period vs Radius \ud83d\udccc Image: ???","title":"Simulation: Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbit-animation-optional","text":"A simple simulation of a satellite orbiting Earth. \ud83d\udccc Animated GIF placeholder: Satellite orbit path simulation \ud83c\udf9e\ufe0f File: ???","title":"Orbit Animation (Optional)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For ellipses, Kepler\u2019s Third Law still holds, but \\(r\\) becomes the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Applies to: - Planetary systems - Comets and asteroids - Exoplanet detection via transit timing","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"The \\(T^2 \\propto r^3\\) relationship connects geometry with dynamics Enables mass/distance calculations for celestial objects Holds in ideal and elliptical orbits, proving essential for astrophysics , satellite design , and space exploration Kepler\u2019s Third Law bridges the gap between Newtonian gravity and orbital motion \u2014 an elegant expression of universal harmony.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Exploring Gravitational Limits Across the Solar System 1. Theoretical Foundation 1.1 Cosmic Velocities Definitions First Cosmic Velocity \\( (v_1) \\) : Minimum speed required to maintain a circular orbit just above a celestial body's surface. $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity \\( (v_2) \\) : Escape velocity from the surface \u2014 the speed needed to break free from gravity without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity \\( (v_3) \\) : Speed required to escape the gravitational field of the Sun from Earth's orbit \u2014 critical for interstellar travel. $$ v_3 = \\sqrt{v_{\\text{sun,escape}}^2 + v_{\\text{orbital}}^2} $$ 2. Mathematical Derivations Gravitational Potential Energy (U): $$ U = -\\frac{GMm}{r} $$ Kinetic Energy (K): $$ K = \\frac{1}{2}mv^2 $$ For escape velocity , total mechanical energy must be \u2265 0: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 $$ \u21d2 $$ v = \\sqrt{\\frac{2GM}{r}} $$ 3. Simulation and Visualization 4.1 Python Simulation Code Click to see the Python simulation code import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Define celestial bodies: [Mass (kg), Radius (m)] bodies = { \"Earth\": [5.972e24, 6.371e6], \"Mars\": [6.39e23, 3.3895e6], \"Jupiter\": [1.898e27, 6.9911e7] } velocities = {\"Body\": [], \"v1 (km/s)\": [], \"v2 (km/s)\": []} for body, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # km/s v2 = np.sqrt(2 * G * M / R) / 1000 # km/s velocities[\"Body\"].append(body) velocities[\"v1 (km/s)\"].append(round(v1, 2)) velocities[\"v2 (km/s)\"].append(round(v2, 2)) # Plotting fig, ax = plt.subplots() index = np.arange(len(bodies)) bar_width = 0.35 bar1 = ax.bar(index, velocities[\"v1 (km/s)\"], bar_width, label='1st Cosmic Velocity') bar2 = ax.bar(index + bar_width, velocities[\"v2 (km/s)\"], bar_width, label='2nd Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index + bar_width / 2) ax.set_xticklabels(velocities[\"Body\"]) ax.legend() plt.grid(True) plt.tight_layout() plt.show() 4. Applications in Space Exploration Velocity Application v\u2081 (Orbital) Launching satellites into Low Earth Orbit (LEO) v\u2082 (Escape) Missions to Moon, Mars, outer planets v\u2083 (Interstellar) Exiting the Solar System (e.g., Voyager) 5. Visual Gallery Escape vs Orbital Velocities Graph from simulation (bar plot of v\u2081 and v\u2082 for Earth, Mars, Jupiter) This bar chart compares the first and second cosmic velocities for Earth, Mars, and Jupiter. The first cosmic velocity represents the speed required for a stable orbit just above the planet's surface, while the second is the escape velocity. The chart visually highlights Jupiter\u2019s strong gravity, resulting in much higher required velocities compared to Earth and Mars. A conceptual illustration depicting the first (v\u2081), second (v\u2082), and third (v\u2083) cosmic velocities with directional annotations from Earth. This GIF shows: v\u2081: Orbit around Earth (gray circle) v\u2082: Escape trajectory (red line) v\u2083: Path escaping the Solar System (green line) 6. Deliverables \u2705 Markdown document with derivations and physical insights \u2705 Python simulation of cosmic velocities \u2705 Graphical plots comparing celestial bodies \u2705 Practical applications across missions 7. Conclusion Escape and cosmic velocities form the foundation for understanding how objects move in and beyond gravitational fields. From achieving stable orbits to enabling interplanetary and interstellar missions , these velocities determine the fuel, design, and feasibility of space travel. The significant variations across celestial bodies like Earth , Mars , and Jupiter reveal how gravitational strength shapes mission planning. Mastering these principles is vital for the continued advancement of space exploration and future technologies aimed at reaching beyond our solar system.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Exploring Gravitational Limits Across the Solar System","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-cosmic-velocities-definitions","text":"First Cosmic Velocity \\( (v_1) \\) : Minimum speed required to maintain a circular orbit just above a celestial body's surface. $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity \\( (v_2) \\) : Escape velocity from the surface \u2014 the speed needed to break free from gravity without further propulsion. $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity \\( (v_3) \\) : Speed required to escape the gravitational field of the Sun from Earth's orbit \u2014 critical for interstellar travel. $$ v_3 = \\sqrt{v_{\\text{sun,escape}}^2 + v_{\\text{orbital}}^2} $$","title":"1.1 Cosmic Velocities Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"Gravitational Potential Energy (U): $$ U = -\\frac{GMm}{r} $$ Kinetic Energy (K): $$ K = \\frac{1}{2}mv^2 $$ For escape velocity , total mechanical energy must be \u2265 0: $$ \\frac{1}{2}mv^2 - \\frac{GMm}{r} \\geq 0 $$ \u21d2 $$ v = \\sqrt{\\frac{2GM}{r}} $$","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-simulation-and-visualization","text":"","title":"3. Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#41-python-simulation-code","text":"Click to see the Python simulation code import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Define celestial bodies: [Mass (kg), Radius (m)] bodies = { \"Earth\": [5.972e24, 6.371e6], \"Mars\": [6.39e23, 3.3895e6], \"Jupiter\": [1.898e27, 6.9911e7] } velocities = {\"Body\": [], \"v1 (km/s)\": [], \"v2 (km/s)\": []} for body, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # km/s v2 = np.sqrt(2 * G * M / R) / 1000 # km/s velocities[\"Body\"].append(body) velocities[\"v1 (km/s)\"].append(round(v1, 2)) velocities[\"v2 (km/s)\"].append(round(v2, 2)) # Plotting fig, ax = plt.subplots() index = np.arange(len(bodies)) bar_width = 0.35 bar1 = ax.bar(index, velocities[\"v1 (km/s)\"], bar_width, label='1st Cosmic Velocity') bar2 = ax.bar(index + bar_width, velocities[\"v2 (km/s)\"], bar_width, label='2nd Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index + bar_width / 2) ax.set_xticklabels(velocities[\"Body\"]) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"4.1 Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-applications-in-space-exploration","text":"Velocity Application v\u2081 (Orbital) Launching satellites into Low Earth Orbit (LEO) v\u2082 (Escape) Missions to Moon, Mars, outer planets v\u2083 (Interstellar) Exiting the Solar System (e.g., Voyager)","title":"4. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-visual-gallery","text":"","title":"5. Visual Gallery"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-vs-orbital-velocities","text":"Graph from simulation (bar plot of v\u2081 and v\u2082 for Earth, Mars, Jupiter) This bar chart compares the first and second cosmic velocities for Earth, Mars, and Jupiter. The first cosmic velocity represents the speed required for a stable orbit just above the planet's surface, while the second is the escape velocity. The chart visually highlights Jupiter\u2019s strong gravity, resulting in much higher required velocities compared to Earth and Mars. A conceptual illustration depicting the first (v\u2081), second (v\u2082), and third (v\u2083) cosmic velocities with directional annotations from Earth. This GIF shows: v\u2081: Orbit around Earth (gray circle) v\u2082: Escape trajectory (red line) v\u2083: Path escaping the Solar System (green line)","title":"Escape vs Orbital Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-deliverables","text":"\u2705 Markdown document with derivations and physical insights \u2705 Python simulation of cosmic velocities \u2705 Graphical plots comparing celestial bodies \u2705 Practical applications across missions","title":"6. Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-conclusion","text":"Escape and cosmic velocities form the foundation for understanding how objects move in and beyond gravitational fields. From achieving stable orbits to enabling interplanetary and interstellar missions , these velocities determine the fuel, design, and feasibility of space travel. The significant variations across celestial bodies like Earth , Mars , and Jupiter reveal how gravitational strength shapes mission planning. Mastering these principles is vital for the continued advancement of space exploration and future technologies aimed at reaching beyond our solar system.","title":"7. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth An Advanced Computational Study of Payload Dynamics Under Gravity 1. Theoretical Foundation 1.1 Problem Context When a payload is released from a moving spacecraft or rocket near Earth, its subsequent motion is governed by Newtonian gravitation. Depending on the initial velocity , altitude , and release angle , the payload may: Enter a stable orbit (elliptical trajectory) Fall back to Earth (reentry path) Escape Earth's gravity entirely (hyperbolic escape) This analysis uses numerical methods to simulate and visualize these outcomes. 1.2 Fundamental Equations The gravitational force from Earth acting on the payload is: $$ \\vec{F}_g = -\\frac{GMm}{r^2}\\hat{r} $$ Where: - \\( G = 6.674 \\times 10^{-11} \\ \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\ \\text{kg} \\) (Earth mass) - \\( r \\) = distance from Earth\u2019s center - \\( \\hat{r} \\) = unit vector pointing away from Earth's center The motion of the payload follows Newton\u2019s second law in polar or Cartesian form. In vector form: \\[ m\\vec{a} = -\\frac{GMm}{r^2} \\hat{r} \\] Resulting in the acceleration components: $$ a_x = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad a_y = -\\frac{GMy}{(x^2 + y^2)^{3/2}} $$ 1.3 Types of Orbital Trajectories The total specific mechanical energy ( \\( \\epsilon \\) ) of the payload determines the shape of the orbit: $$ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} $$ Energy \\( \\epsilon \\) Trajectory Type Description \\( \\epsilon < 0 \\) Elliptical Bound orbit, payload circles Earth \\( \\epsilon = 0 \\) Parabolic Escape trajectory, critical velocity \\( \\epsilon > 0 \\) Hyperbolic Escapes Earth with excess energy 2. Realistic Initial Conditions and Earth Model Parameter Value Description Earth's radius \\( R_E = 6.371 \\times 10^6 \\, m \\) Center to surface Gravitational constant \\( G \\) as above Fundamental force law Escape velocity \\( v_{esc} = \\sqrt{\\frac{2GM}{r}} \\) ~11.2 km/s at surface Initial altitude e.g., 300 km Typical LEO release height Velocity profile Tangential release As from a spacecraft orbit path 3. Python-Based Orbital Simulator Click to expand the Python code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] def simulate_orbit(x0, y0, vx0, vy0, duration=20000): y_init = [x0, vx0, y0, vy0] sol = solve_ivp(gravity, [0, duration], y_init, t_eval=np.linspace(0, duration, 10000)) return sol 4. Trajectory Simulations & Interpretations We simulate 3 cases with different initial speeds: 4.1 Case 1: Elliptical Orbit (Stable Bound Orbit) Initial Altitude: 300 km Tangential Speed: 7.7 km/s Energy: \\( \\epsilon < 0 \\) This results in a closed elliptical orbit , suitable for satellite deployment. Elliptical trajectory: payload follows a curved, stable path around Earth with constant gravitational pull. 4.2 Case 2: Parabolic Escape (Edge of Escape) Initial Altitude: 300 km Tangential Speed: ~10.9 km/s Energy: \\( \\epsilon = 0 \\) The payload escapes Earth's gravity at just the minimum required speed. Parabolic trajectory: the payload moves infinitely far from Earth, slowing as it goes, but never returning. 4.3 Case 3: Hyperbolic Escape (Excess Speed) Initial Altitude: 300 km Tangential Speed: >11.2 km/s Energy: \\( \\epsilon > 0 \\) The payload accelerates away from Earth, following an open hyperbola. Hyperbolic trajectory: represents a high-energy interplanetary mission or failed deorbit. 5. Extended Discussion: Mission Scenarios Application Area Preferred Trajectory Required Adjustments Satellite Deployment Elliptical Controlled orbital insertion via thrust vectoring Reentry Missions Sub-orbital / Elliptical Must decelerate for descent Interplanetary Probe Hyperbolic Needs escape speed and direction planning Space Junk Mitigation Reentry or capture Deorbit maneuvers from LEO orbits 6. Summary of Deliverables \u2705 3 Distinct Trajectory Simulations \u2705 Annotated Graphs showing Earth, orbit, and direction \u2705 Numerical Python Model (solve_ivp + gravity physics) \u2705 Comprehensive Explanation of Orbital Energy \u2705 Real-world Application Scenarios (satellites, missions, debris)","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"An Advanced Computational Study of Payload Dynamics Under Gravity","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#11-problem-context","text":"When a payload is released from a moving spacecraft or rocket near Earth, its subsequent motion is governed by Newtonian gravitation. Depending on the initial velocity , altitude , and release angle , the payload may: Enter a stable orbit (elliptical trajectory) Fall back to Earth (reentry path) Escape Earth's gravity entirely (hyperbolic escape) This analysis uses numerical methods to simulate and visualize these outcomes.","title":"1.1 Problem Context"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-fundamental-equations","text":"The gravitational force from Earth acting on the payload is: $$ \\vec{F}_g = -\\frac{GMm}{r^2}\\hat{r} $$ Where: - \\( G = 6.674 \\times 10^{-11} \\ \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\ \\text{kg} \\) (Earth mass) - \\( r \\) = distance from Earth\u2019s center - \\( \\hat{r} \\) = unit vector pointing away from Earth's center The motion of the payload follows Newton\u2019s second law in polar or Cartesian form. In vector form: \\[ m\\vec{a} = -\\frac{GMm}{r^2} \\hat{r} \\] Resulting in the acceleration components: $$ a_x = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad a_y = -\\frac{GMy}{(x^2 + y^2)^{3/2}} $$","title":"1.2 Fundamental Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#13-types-of-orbital-trajectories","text":"The total specific mechanical energy ( \\( \\epsilon \\) ) of the payload determines the shape of the orbit: $$ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} $$ Energy \\( \\epsilon \\) Trajectory Type Description \\( \\epsilon < 0 \\) Elliptical Bound orbit, payload circles Earth \\( \\epsilon = 0 \\) Parabolic Escape trajectory, critical velocity \\( \\epsilon > 0 \\) Hyperbolic Escapes Earth with excess energy","title":"1.3 Types of Orbital Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-realistic-initial-conditions-and-earth-model","text":"Parameter Value Description Earth's radius \\( R_E = 6.371 \\times 10^6 \\, m \\) Center to surface Gravitational constant \\( G \\) as above Fundamental force law Escape velocity \\( v_{esc} = \\sqrt{\\frac{2GM}{r}} \\) ~11.2 km/s at surface Initial altitude e.g., 300 km Typical LEO release height Velocity profile Tangential release As from a spacecraft orbit path","title":"2. Realistic Initial Conditions and Earth Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-based-orbital-simulator","text":"Click to expand the Python code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def gravity(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] def simulate_orbit(x0, y0, vx0, vy0, duration=20000): y_init = [x0, vx0, y0, vy0] sol = solve_ivp(gravity, [0, duration], y_init, t_eval=np.linspace(0, duration, 10000)) return sol","title":"3. Python-Based Orbital Simulator"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-trajectory-simulations-interpretations","text":"We simulate 3 cases with different initial speeds:","title":"4. Trajectory Simulations &amp; Interpretations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#41-case-1-elliptical-orbit-stable-bound-orbit","text":"Initial Altitude: 300 km Tangential Speed: 7.7 km/s Energy: \\( \\epsilon < 0 \\) This results in a closed elliptical orbit , suitable for satellite deployment. Elliptical trajectory: payload follows a curved, stable path around Earth with constant gravitational pull.","title":"4.1 Case 1: Elliptical Orbit (Stable Bound Orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#42-case-2-parabolic-escape-edge-of-escape","text":"Initial Altitude: 300 km Tangential Speed: ~10.9 km/s Energy: \\( \\epsilon = 0 \\) The payload escapes Earth's gravity at just the minimum required speed. Parabolic trajectory: the payload moves infinitely far from Earth, slowing as it goes, but never returning.","title":"4.2 Case 2: Parabolic Escape (Edge of Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#43-case-3-hyperbolic-escape-excess-speed","text":"Initial Altitude: 300 km Tangential Speed: >11.2 km/s Energy: \\( \\epsilon > 0 \\) The payload accelerates away from Earth, following an open hyperbola. Hyperbolic trajectory: represents a high-energy interplanetary mission or failed deorbit.","title":"4.3 Case 3: Hyperbolic Escape (Excess Speed)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-extended-discussion-mission-scenarios","text":"Application Area Preferred Trajectory Required Adjustments Satellite Deployment Elliptical Controlled orbital insertion via thrust vectoring Reentry Missions Sub-orbital / Elliptical Must decelerate for descent Interplanetary Probe Hyperbolic Needs escape speed and direction planning Space Junk Mitigation Reentry or capture Deorbit maneuvers from LEO orbits","title":"5. Extended Discussion: Mission Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-summary-of-deliverables","text":"\u2705 3 Distinct Trajectory Simulations \u2705 Annotated Graphs showing Earth, orbit, and direction \u2705 Numerical Python Model (solve_ivp + gravity physics) \u2705 Comprehensive Explanation of Orbital Energy \u2705 Real-world Application Scenarios (satellites, missions, debris)","title":"6. Summary of Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a water surface A Deep Dive into Circular Wave Superposition and Interference Patterns 1. Theoretical Foundation 1.1 Single Disturbance Wave Equation A point source located at \\((x_0, y_0)\\) on a water surface emits circular waves governed by the Single Disturbance Equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos \\left(kr - \\omega t + \\phi\\right) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement - \\(A\\) : Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number - \\(\\omega = 2\\pi f\\) : Angular frequency - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source - \\(\\phi\\) : Initial phase 1.2 Superposition from Multiple Sources For \\(N\\) coherent sources placed at the vertices of a regular polygon, the total displacement at any point is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos \\left(kr_i - \\omega t + \\phi_i\\right) \\] Where \\(r_i\\) is the distance from the \\(i^{th}\\) source to \\((x, y)\\) , and \\(\\phi_i\\) is its phase. 2. Regular Polygon Source Configuration 2.1 Chosen Polygon: Square We analyze a square (4 vertices) centered at the origin with equal spacing and each vertex emitting coherent waves. Let vertices be located at: - \\(S_1 = (-d, -d)\\) - \\(S_2 = (-d, d)\\) - \\(S_3 = (d, d)\\) - \\(S_4 = (d, -d)\\) All sources share: - Same amplitude \\(A\\) - Frequency \\(f\\) - Wavelength \\(\\lambda\\) - Phase \\(\\phi = 0\\) 3. Simulation and Visualization 3.1 Python Simulation Code Click to view the code import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters A = 1 # Amplitude f = 1 # Frequency (Hz) \u03bb = 2 # Wavelength k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 d = 5 # Half-length of square side sources = [(-d, -d), (-d, d), (d, d), (d, -d)] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) def compute_eta(X, Y, t): eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta += A / np.sqrt(r) * np.cos(k * r - \u03c9 * t + \u03c6) return eta # Plot a snapshot t0 = 0 Z = compute_eta(X, Y, t0) plt.figure(figsize=(8,6)) plt.contourf(X, Y, Z, cmap='viridis', levels=100) plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern at t=0') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() 3.2 Key Visualizations 1. Animated Propagation (GIF) Description : A dynamic visualization showing how the interference pattern evolves over time. Wavefronts radiate outward and continuously interfere, with the square symmetry preserved in the oscillations. 2. Constructive and Destructive Interference This image is a 3D surface plot representing the displacement of a water surface over a two-dimensional grid of \\(x\\) and \\(y\\) values. The plot uses a color gradient from blue to red to indicate changes in the vertical displacement (z-axis) \u2014 with blue areas representing troughs (lower values) and red areas representing peaks (higher values). 3.1 Key Features: Axes : x-axis and y-axis range from approximately -5 to 5. The z-axis shows the displacement, ranging roughly between -2.5 to 2.5. Color Map : The plot uses a coolwarm colormap, giving a heatmap-like effect to indicate depth and elevation. Surface Shape : The surface has a wavy, undulating form with multiple peaks and valleys, simulating the complex nature of a water surface disturbed by waves or external forces. Title : The plot is titled \"3D Water Surface Displacement\" , clearly indicating its purpose \u2014 to visualize dynamic changes on a fluid surface. This kind of visualization is useful in simulations involving fluid dynamics , wave propagation , or surface deformation analysis. 4. Observations and Analysis 4.1 Interference Characteristics Constructive interference occurs at points equidistant from multiple sources. Destructive interference is observed at points with phase opposition from different wave contributions. Symmetry of the polygon determines the spatial periodicity of the pattern. 4.2 Parameters Affecting the Pattern Parameter Effect Wavelength ( \\(\\lambda\\) ) Affects spacing between interference fringes Frequency ( \\(f\\) ) Alters time dynamics of the pattern Distance between sources Changes pattern density and fringe separation 5. Extensions Try different polygon configurations (e.g., triangle, pentagon) Introduce phase shifts between sources Explore non-equal amplitudes or frequencies Model nonlinear effects or surface damping 6.Conclusion This simulation vividly illustrates how wave superposition from symmetric point sources leads to rich, predictable interference patterns. The square layout results in a periodic, symmetric wave field that reflects the coherence and geometry of the sources.","title":"Interference Patterns on a water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"A Deep Dive into Circular Wave Superposition and Interference Patterns","title":"Interference Patterns on a water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#11-single-disturbance-wave-equation","text":"A point source located at \\((x_0, y_0)\\) on a water surface emits circular waves governed by the Single Disturbance Equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos \\left(kr - \\omega t + \\phi\\right) \\] Where: - \\(\\eta(x, y, t)\\) : Water surface displacement - \\(A\\) : Amplitude - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number - \\(\\omega = 2\\pi f\\) : Angular frequency - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source - \\(\\phi\\) : Initial phase","title":"1.1 Single Disturbance Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#12-superposition-from-multiple-sources","text":"For \\(N\\) coherent sources placed at the vertices of a regular polygon, the total displacement at any point is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos \\left(kr_i - \\omega t + \\phi_i\\right) \\] Where \\(r_i\\) is the distance from the \\(i^{th}\\) source to \\((x, y)\\) , and \\(\\phi_i\\) is its phase.","title":"1.2 Superposition from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-regular-polygon-source-configuration","text":"","title":"2. Regular Polygon Source Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-chosen-polygon-square","text":"We analyze a square (4 vertices) centered at the origin with equal spacing and each vertex emitting coherent waves. Let vertices be located at: - \\(S_1 = (-d, -d)\\) - \\(S_2 = (-d, d)\\) - \\(S_3 = (d, d)\\) - \\(S_4 = (d, -d)\\) All sources share: - Same amplitude \\(A\\) - Frequency \\(f\\) - Wavelength \\(\\lambda\\) - Phase \\(\\phi = 0\\)","title":"2.1 Chosen Polygon: Square"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-simulation-and-visualization","text":"","title":"3. Simulation and Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#31-python-simulation-code","text":"Click to view the code import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters A = 1 # Amplitude f = 1 # Frequency (Hz) \u03bb = 2 # Wavelength k = 2 * np.pi / \u03bb \u03c9 = 2 * np.pi * f \u03c6 = 0 d = 5 # Half-length of square side sources = [(-d, -d), (-d, d), (d, d), (d, -d)] # Grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) def compute_eta(X, Y, t): eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 eta += A / np.sqrt(r) * np.cos(k * r - \u03c9 * t + \u03c6) return eta # Plot a snapshot t0 = 0 Z = compute_eta(X, Y, t0) plt.figure(figsize=(8,6)) plt.contourf(X, Y, Z, cmap='viridis', levels=100) plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern at t=0') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"3.1 Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#32-key-visualizations","text":"","title":"3.2 Key Visualizations"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-animated-propagation-gif","text":"Description : A dynamic visualization showing how the interference pattern evolves over time. Wavefronts radiate outward and continuously interfere, with the square symmetry preserved in the oscillations.","title":"1. Animated Propagation (GIF)"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-constructive-and-destructive-interference","text":"This image is a 3D surface plot representing the displacement of a water surface over a two-dimensional grid of \\(x\\) and \\(y\\) values. The plot uses a color gradient from blue to red to indicate changes in the vertical displacement (z-axis) \u2014 with blue areas representing troughs (lower values) and red areas representing peaks (higher values).","title":"2. Constructive and Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#31-key-features","text":"Axes : x-axis and y-axis range from approximately -5 to 5. The z-axis shows the displacement, ranging roughly between -2.5 to 2.5. Color Map : The plot uses a coolwarm colormap, giving a heatmap-like effect to indicate depth and elevation. Surface Shape : The surface has a wavy, undulating form with multiple peaks and valleys, simulating the complex nature of a water surface disturbed by waves or external forces. Title : The plot is titled \"3D Water Surface Displacement\" , clearly indicating its purpose \u2014 to visualize dynamic changes on a fluid surface. This kind of visualization is useful in simulations involving fluid dynamics , wave propagation , or surface deformation analysis.","title":"3.1 Key Features:"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#41-interference-characteristics","text":"Constructive interference occurs at points equidistant from multiple sources. Destructive interference is observed at points with phase opposition from different wave contributions. Symmetry of the polygon determines the spatial periodicity of the pattern.","title":"4.1 Interference Characteristics"},{"location":"1%20Physics/3%20Waves/Problem_1/#42-parameters-affecting-the-pattern","text":"Parameter Effect Wavelength ( \\(\\lambda\\) ) Affects spacing between interference fringes Frequency ( \\(f\\) ) Alters time dynamics of the pattern Distance between sources Changes pattern density and fringe separation","title":"4.2 Parameters Affecting the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-extensions","text":"Try different polygon configurations (e.g., triangle, pentagon) Introduce phase shifts between sources Explore non-equal amplitudes or frequencies Model nonlinear effects or surface damping","title":"5. Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#6conclusion","text":"This simulation vividly illustrates how wave superposition from symmetric point sources leads to rich, predictable interference patterns. The square layout results in a periodic, symmetric wave field that reflects the coherence and geometry of the sources.","title":"6.Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory 1. Introduction & Motivation When dealing with complex resistor networks, traditional reduction methods (series-parallel rules) often become tedious and error-prone. Graph theory provides a robust framework to automate and simplify this process by treating the circuit as a weighted undirected graph : Nodes = Circuit junctions Edges = Resistors (weights = resistance values) By employing graph traversal algorithms , we can iteratively identify series and parallel connections and simplify them\u2014making this approach ideal for simulation software and scalable to large systems. 2. Algorithm Description (Pseudocode) High-Level Steps: Represent the Circuit as a Graph Identify Simplifiable Subgraphs (Series or Parallel) Iteratively Reduce until a single edge remains between the source and target nodes. Pseudocode: Equivalent Resistance Reduction Input: Graph G(V, E), where each edge has resistance R function EquivalentResistance(G, source, target): while number_of_nodes(G) > 2: for each node n in G: if degree(n) == 2: reduce_series(n) for each pair of nodes (u, v): if multiple_edges(u, v): reduce_parallel(u, v) return resistance_between(source, target) function reduce_series(node n): neighbors = [u, v] # nodes connected to n R_total = R(n, u) + R(n, v) remove node n and its edges add edge(u, v) with resistance R_total function reduce_parallel(u, v): R_eq = 1 / sum(1 / R for each edge(u, v)) remove all edges(u, v) add edge(u, v) with resistance R_eq 3. Python Implementation (Click to View Code) Click to see the Python code import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes): if G.degree[node] == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[node][u]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break return G def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = list(G.get_edge_data(u, v).values()) if len(parallel_edges) > 1: R_eq = 1 / sum(1 / edge['resistance'] for edge in parallel_edges) G.remove_edges_from([(u, v)] * len(parallel_edges)) G.add_edge(u, v, resistance=R_eq) return G def equivalent_resistance(G, source, target): G = reduce_series(G) G = reduce_parallel(G) return G[source][target]['resistance'] 4. Example Circuit Configurations \u2705 Example 1: Simple Series A --[2\u03a9]-- B --[3\u03a9]-- C Equivalent: 5\u03a9 \u2705 Example 2: Parallel Branches A --[2\u03a9]-- B A --[2\u03a9]-- B Equivalent: 1\u03a9 \u2705 Example 3: Nested Graph (Series + Parallel) A --[2\u03a9]-- B --[3\u03a9]-- C A --[5\u03a9]-- C Series: A-B-C = 5\u03a9 Parallel with A-C = 5\u03a9 Total: \\( \\frac{1}{\\frac{1}{5} + \\frac{1}{5}} = 2.5\u03a9 \\) 5. Algorithm Analysis \u23f1\ufe0f Time Complexity Series reduction : O(V) Parallel detection : O(E\u00b2) in worst case (multiple edge check) For sparse circuits: \u2248 linear to number of components. \ud83e\udde0 Advantages Handles complex and nested networks Automatable using libraries like NetworkX Adaptable to symbolic or variable resistors \ud83d\ude80 Improvements Incorporate cycle detection (DFS/BFS) for general loop analysis Use Kirchhoff\u2019s laws for edge cases (non-reducible graphs) Allow symbolic algebra (SymPy) for unknown resistors","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-motivation","text":"When dealing with complex resistor networks, traditional reduction methods (series-parallel rules) often become tedious and error-prone. Graph theory provides a robust framework to automate and simplify this process by treating the circuit as a weighted undirected graph : Nodes = Circuit junctions Edges = Resistors (weights = resistance values) By employing graph traversal algorithms , we can iteratively identify series and parallel connections and simplify them\u2014making this approach ideal for simulation software and scalable to large systems.","title":"1. Introduction &amp; Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-algorithm-description-pseudocode","text":"","title":"2. Algorithm Description (Pseudocode)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#high-level-steps","text":"Represent the Circuit as a Graph Identify Simplifiable Subgraphs (Series or Parallel) Iteratively Reduce until a single edge remains between the source and target nodes.","title":"High-Level Steps:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#pseudocode-equivalent-resistance-reduction","text":"Input: Graph G(V, E), where each edge has resistance R function EquivalentResistance(G, source, target): while number_of_nodes(G) > 2: for each node n in G: if degree(n) == 2: reduce_series(n) for each pair of nodes (u, v): if multiple_edges(u, v): reduce_parallel(u, v) return resistance_between(source, target) function reduce_series(node n): neighbors = [u, v] # nodes connected to n R_total = R(n, u) + R(n, v) remove node n and its edges add edge(u, v) with resistance R_total function reduce_parallel(u, v): R_eq = 1 / sum(1 / R for each edge(u, v)) remove all edges(u, v) add edge(u, v) with resistance R_eq","title":"Pseudocode: Equivalent Resistance Reduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-python-implementation-click-to-view-code","text":"Click to see the Python code import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes): if G.degree[node] == 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors R1 = G[node][u]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break return G def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = list(G.get_edge_data(u, v).values()) if len(parallel_edges) > 1: R_eq = 1 / sum(1 / edge['resistance'] for edge in parallel_edges) G.remove_edges_from([(u, v)] * len(parallel_edges)) G.add_edge(u, v, resistance=R_eq) return G def equivalent_resistance(G, source, target): G = reduce_series(G) G = reduce_parallel(G) return G[source][target]['resistance']","title":"3. Python Implementation (Click to View Code)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-example-circuit-configurations","text":"","title":"4. Example Circuit Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-1-simple-series","text":"A --[2\u03a9]-- B --[3\u03a9]-- C Equivalent: 5\u03a9","title":"\u2705 Example 1: Simple Series"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-2-parallel-branches","text":"A --[2\u03a9]-- B A --[2\u03a9]-- B Equivalent: 1\u03a9","title":"\u2705 Example 2: Parallel Branches"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-3-nested-graph-series-parallel","text":"A --[2\u03a9]-- B --[3\u03a9]-- C A --[5\u03a9]-- C Series: A-B-C = 5\u03a9 Parallel with A-C = 5\u03a9 Total: \\( \\frac{1}{\\frac{1}{5} + \\frac{1}{5}} = 2.5\u03a9 \\)","title":"\u2705 Example 3: Nested Graph (Series + Parallel)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-algorithm-analysis","text":"","title":"5. Algorithm Analysis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#time-complexity","text":"Series reduction : O(V) Parallel detection : O(E\u00b2) in worst case (multiple edge check) For sparse circuits: \u2248 linear to number of components.","title":"\u23f1\ufe0f Time Complexity"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#advantages","text":"Handles complex and nested networks Automatable using libraries like NetworkX Adaptable to symbolic or variable resistors","title":"\ud83e\udde0 Advantages"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#improvements","text":"Incorporate cycle detection (DFS/BFS) for general loop analysis Use Kirchhoff\u2019s laws for edge cases (non-reducible graphs) Allow symbolic algebra (SymPy) for unknown resistors","title":"\ud83d\ude80 Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"}]}