{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import cm from mpl_toolkits.mplot3d import Axes3D from matplotlib.animation import FuncAnimation from ipywidgets import interact, FloatSlider, IntSlider, Dropdown, ToggleButtons import ipywidgets as widgets from scipy.integrate import odeint from sklearn.ensemble import RandomForestRegressor from sympy import symbols, Eq, init_printing, latex import random from tqdm import tqdm import seaborn as sns from PIL import Image from matplotlib.offsetbox import OffsetImage, AnnotationBbox ============================================= 1. PHYSICS ENGINE WITH ALL REAL-WORLD EFFECTS ============================================= class ProjectileSimulator: def init (self): # Physical constants self.g_earth = 9.80665 # m/s\u00b2 self.g_moon = 1.62 # m/s\u00b2 self.g_mars = 3.721 # m/s\u00b2 self.rho_earth = 1.225 # kg/m\u00b3 (air density) self.Cd_sphere = 0.47 # Drag coefficient # Visual settings self.colors = { 'earth': '#2E86AB', 'moon': '#A5A5A5', 'mars': '#E2725B', 'trajectory': '#FF9F1C', 'highlight': '#FF3366' } self.plt_style = 'seaborn-darkgrid' plt.style.use(self.plt_style) def simulate_trajectory(self, v0, theta, g=9.81, h0=0, drag=False, spin=0, wind=0, dt=0.001): \"\"\"Advanced physics simulation with multiple effects\"\"\" theta_rad = np.radians(theta) t = 0 x, y = 0, h0 vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Store trajectory points x_points, y_points, t_points = [x], [y], [t] while y >= 0: if drag: # Calculate drag force (quadratic model) v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * self.rho_earth * self.Cd_sphere * 0.018 * v**2 # Calculate Magnus effect (simplified) Fm = 0.25 * self.rho_earth * 0.018 * (spin*2*np.pi/60) * v # Acceleration components ax = -Fd/m * vx/v + Fm/m * vy/v + wind ay = -g - Fd/m * vy/v - Fm/m * vx/v else: ax = wind ay = -g # Update velocity and position vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt t += dt # Store points x_points.append(x) y_points.append(y) t_points.append(t) return np.array(x_points), np.array(y_points), np.array(t_points) def calculate_range(self, v0, theta, **kwargs): \"\"\"Calculate the horizontal range\"\"\" x, y, _ = self.simulate_trajectory(v0, theta, **kwargs) return x[-1] if len(x) > 0 else 0 ============================================= 2. VISUALIZATION ENGINE WITH SPECIAL EFFECTS ============================================= class ProjectileVisualizer: def init (self): self.sim = ProjectileSimulator() self.fig = None self.ax = None # Custom colormaps self.cmap1 = cm.get_cmap('plasma') self.cmap2 = cm.get_cmap('viridis') # Load celestial body images self.planet_imgs = { 'earth': Image.open('earth_texture.jpg'), 'moon': Image.open('moon_texture.jpg'), 'mars': Image.open('mars_texture.jpg') } def _add_planet_bg(self, planet): \"\"\"Add planetary background to plot\"\"\" if planet in self.planet_imgs: img = self.planet_imgs[planet] imagebox = OffsetImage(img, zoom=0.2) ab = AnnotationBbox(imagebox, (0.5, 0.5), frameon=False) self.ax.add_artist(ab) def plot_trajectory(self, v0=20, theta=45, g=9.81, h0=0, drag=False, spin=0, wind=0, planet='earth'): \"\"\"Plot a single trajectory with special effects\"\"\" self.fig, self.ax = plt.subplots(figsize=(12, 8)) # Get trajectory data x, y, t = self.sim.simulate_trajectory(v0, theta, g, h0, drag, spin, wind) # Create glowing trajectory effect n_points = len(x) for i in range(n_points): alpha = i/n_points * 0.8 + 0.2 self.ax.plot(x[:i+1], y[:i+1], color=self.sim.colors['trajectory'], alpha=alpha, lw=3) # Add impact explosion effect if n_points > 0: self.ax.scatter(x[-1], 0, s=500, c='red', alpha=0.6, marker='*', edgecolors='gold', linewidths=2) # Add planet background self._add_planet_bg(planet) # Customize plot self.ax.set_title(f\"Projectile Motion Simulation\\n\" f\"v\u2080 = {v0} m/s, \u03b8 = {theta}\u00b0, g = {g} m/s\u00b2\", fontsize=16, pad=20) self.ax.set_xlabel(\"Horizontal Distance (m)\") self.ax.set_ylabel(\"Height (m)\") self.ax.grid(True, alpha=0.3) # Add colorbar for time norm = plt.Normalize(t.min(), t.max()) sm = plt.cm.ScalarMappable(cmap=self.cmap1, norm=norm) sm.set_array([]) cbar = plt.colorbar(sm, ax=self.ax) cbar.set_label('Time (s)') plt.tight_layout() plt.show() def plot_3d_surface(self): \"\"\"Create 3D surface plot of range vs v0 and theta\"\"\" fig = plt.figure(figsize=(16, 10)) ax = fig.add_subplot(111, projection='3d') # Generate data v0_values = np.linspace(10, 50, 30) theta_values = np.linspace(0, 90, 30) V0, THETA = np.meshgrid(v0_values, theta_values) R = np.zeros_like(V0) for i in tqdm(range(len(v0_values))): for j in range(len(theta_values)): R[j,i] = self.sim.calculate_range(V0[j,i], THETA[j,i]) # Plot surface with special effects surf = ax.plot_surface(V0, THETA, R, cmap=self.cmap2, rstride=1, cstride=1, alpha=0.8, edgecolor='none', shade=True) # Add contour projections ax.contourf(V0, THETA, R, zdir='z', offset=R.min(), cmap=self.cmap2, alpha=0.3) # Customize ax.set_title(\"Range as Function of Velocity and Angle\", fontsize=16, pad=20) ax.set_xlabel(\"Initial Velocity (m/s)\") ax.set_ylabel(\"Launch Angle (deg)\") ax.set_zlabel(\"Range (m)\") ax.view_init(elev=30, azim=45) # Add colorbar fig.colorbar(surf, shrink=0.5, aspect=10, label='Range (m)') plt.tight_layout() plt.show() ============================================= 3. INTERACTIVE DASHBOARD ============================================= class InteractiveDashboard: def init (self): self.vis = ProjectileVisualizer() self.setup_widgets() def setup_widgets(self): \"\"\"Create interactive controls\"\"\" self.v0_slider = FloatSlider( value=20, min=5, max=100, step=1, description='Initial Velocity (m/s):', style={'description_width': 'initial'}, continuous_update=False ) self.theta_slider = IntSlider( value=45, min=0, max=90, step=1, description='Launch Angle (deg):', style={'description_width': 'initial'} ) self.g_dropdown = Dropdown( options={'Earth (9.81 m/s\u00b2)': 9.81, 'Moon (1.62 m/s\u00b2)': 1.62, 'Mars (3.72 m/s\u00b2)': 3.72}, value=9.81, description='Gravity:', style={'description_width': 'initial'} ) self.drag_toggle = ToggleButtons( options=['No Drag', 'With Drag'], value='No Drag', description='Air Resistance:', style={'description_width': 'initial'} ) self.spin_slider = FloatSlider( value=0, min=-5000, max=5000, step=100, description='Spin (rpm):', style={'description_width': 'initial'}, disabled=True ) self.wind_slider = FloatSlider( value=0, min=-10, max=10, step=0.5, description='Wind Speed (m/s):', style={'description_width': 'initial'}, disabled=True ) # Link widgets def update_drag_options(change): self.spin_slider.disabled = change['new'] == 'No Drag' self.wind_slider.disabled = change['new'] == 'No Drag' self.drag_toggle.observe(update_drag_options, names='value') def launch(self): \"\"\"Start interactive dashboard\"\"\" interact_manual( self.vis.plot_trajectory, v0=self.v0_slider, theta=self.theta_slider, g=self.g_dropdown, drag=widgets.fixed(self.drag_toggle.value == 'With Drag'), spin=self.spin_slider, wind=self.wind_slider, planet=widgets.fixed('earth') ) ============================================= 4. MACHINE LEARNING OPTIMIZATION ============================================= class ProjectileOptimizer: def init (self): self.model = None self.train_model() def generate_training_data(self, n_samples=1000): \"\"\"Create dataset for ML model\"\"\" X = [] y = [] for _ in range(n_samples): v0 = random.uniform(5, 100) h0 = random.uniform(0, 50) g = random.uniform(1.62, 24.79) # Moon to Jupiter gravity # Find optimal angle numerically angles = np.linspace(0, 90, 91) ranges = [self.calculate_range(v0, a, g, h0) for a in angles] opt_angle = angles[np.argmax(ranges)] X.append([v0, h0, g]) y.append(opt_angle) return np.array(X), np.array(y) def train_model(self): \"\"\"Train Random Forest regressor\"\"\" X, y = self.generate_training_data() self.model = RandomForestRegressor(n_estimators=100) self.model.fit(X, y) def predict_optimal_angle(self, v0, h0, g): \"\"\"Predict optimal launch angle using ML\"\"\" return self.model.predict([[v0, h0, g]])[0] ============================================= 5. MAIN EXECUTION ============================================= if name == \" main \": print(\"\ud83d\ude80 Launching Ultimate Projectile Motion Simulator\") # Initialize components simulator = ProjectileSimulator() visualizer = ProjectileVisualizer() dashboard = InteractiveDashboard() optimizer = ProjectileOptimizer() # Example: Predict optimal angle for Mars conditions v0_example = 30 h0_example = 10 g_mars = 3.721 opt_angle = optimizer.predict_optimal_angle(v0_example, h0_example, g_mars) print(f\"\\n\u2728 ML Prediction: For v0={v0_example} m/s, h0={h0_example} m, g={g_mars} m/s\u00b2\") print(f\" Optimal launch angle = {opt_angle:.1f}\u00b0\") # Generate all visualizations print(\"\\n\ud83d\uddbc\ufe0f Generating visualizations...\") visualizer.plot_trajectory(v0=25, theta=45, g=9.81, drag=True, spin=2000) visualizer.plot_3d_surface() # Launch interactive dashboard print(\"\\n\ud83c\udfae Launching interactive dashboard...\") dashboard.launch() print(\"\\n\u2705 Simulation complete! Explore the interactive widgets above.\") ============================================= 6. UNIT TESTS AND VALIDATION ============================================= def run_tests(): \"\"\"Validate physics calculations\"\"\" print(\"\\n\ud83d\udd2c Running unit tests...\") # Basic projectile motion x, y, t = simulator.simulate_trajectory(20, 45) assert abs(x[-1] - 40.77) < 0.1, \"Basic range calculation failed\" # Zero gravity edge case x, y, t = simulator.simulate_trajectory(10, 45, g=1e-9) assert x[-1] > 1e6, \"Zero gravity behavior incorrect\" print(\"\u2705 All tests passed!\") run_tests()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-physics-engine-with-all-real-world-effects","text":"","title":"1. PHYSICS ENGINE WITH ALL REAL-WORLD EFFECTS"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"class ProjectileSimulator: def init (self): # Physical constants self.g_earth = 9.80665 # m/s\u00b2 self.g_moon = 1.62 # m/s\u00b2 self.g_mars = 3.721 # m/s\u00b2 self.rho_earth = 1.225 # kg/m\u00b3 (air density) self.Cd_sphere = 0.47 # Drag coefficient # Visual settings self.colors = { 'earth': '#2E86AB', 'moon': '#A5A5A5', 'mars': '#E2725B', 'trajectory': '#FF9F1C', 'highlight': '#FF3366' } self.plt_style = 'seaborn-darkgrid' plt.style.use(self.plt_style) def simulate_trajectory(self, v0, theta, g=9.81, h0=0, drag=False, spin=0, wind=0, dt=0.001): \"\"\"Advanced physics simulation with multiple effects\"\"\" theta_rad = np.radians(theta) t = 0 x, y = 0, h0 vx = v0 * np.cos(theta_rad) vy = v0 * np.sin(theta_rad) # Store trajectory points x_points, y_points, t_points = [x], [y], [t] while y >= 0: if drag: # Calculate drag force (quadratic model) v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * self.rho_earth * self.Cd_sphere * 0.018 * v**2 # Calculate Magnus effect (simplified) Fm = 0.25 * self.rho_earth * 0.018 * (spin*2*np.pi/60) * v # Acceleration components ax = -Fd/m * vx/v + Fm/m * vy/v + wind ay = -g - Fd/m * vy/v - Fm/m * vx/v else: ax = wind ay = -g # Update velocity and position vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt t += dt # Store points x_points.append(x) y_points.append(y) t_points.append(t) return np.array(x_points), np.array(y_points), np.array(t_points) def calculate_range(self, v0, theta, **kwargs): \"\"\"Calculate the horizontal range\"\"\" x, y, _ = self.simulate_trajectory(v0, theta, **kwargs) return x[-1] if len(x) > 0 else 0","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_3","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-visualization-engine-with-special-effects","text":"","title":"2. VISUALIZATION ENGINE WITH SPECIAL EFFECTS"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_4","text":"class ProjectileVisualizer: def init (self): self.sim = ProjectileSimulator() self.fig = None self.ax = None # Custom colormaps self.cmap1 = cm.get_cmap('plasma') self.cmap2 = cm.get_cmap('viridis') # Load celestial body images self.planet_imgs = { 'earth': Image.open('earth_texture.jpg'), 'moon': Image.open('moon_texture.jpg'), 'mars': Image.open('mars_texture.jpg') } def _add_planet_bg(self, planet): \"\"\"Add planetary background to plot\"\"\" if planet in self.planet_imgs: img = self.planet_imgs[planet] imagebox = OffsetImage(img, zoom=0.2) ab = AnnotationBbox(imagebox, (0.5, 0.5), frameon=False) self.ax.add_artist(ab) def plot_trajectory(self, v0=20, theta=45, g=9.81, h0=0, drag=False, spin=0, wind=0, planet='earth'): \"\"\"Plot a single trajectory with special effects\"\"\" self.fig, self.ax = plt.subplots(figsize=(12, 8)) # Get trajectory data x, y, t = self.sim.simulate_trajectory(v0, theta, g, h0, drag, spin, wind) # Create glowing trajectory effect n_points = len(x) for i in range(n_points): alpha = i/n_points * 0.8 + 0.2 self.ax.plot(x[:i+1], y[:i+1], color=self.sim.colors['trajectory'], alpha=alpha, lw=3) # Add impact explosion effect if n_points > 0: self.ax.scatter(x[-1], 0, s=500, c='red', alpha=0.6, marker='*', edgecolors='gold', linewidths=2) # Add planet background self._add_planet_bg(planet) # Customize plot self.ax.set_title(f\"Projectile Motion Simulation\\n\" f\"v\u2080 = {v0} m/s, \u03b8 = {theta}\u00b0, g = {g} m/s\u00b2\", fontsize=16, pad=20) self.ax.set_xlabel(\"Horizontal Distance (m)\") self.ax.set_ylabel(\"Height (m)\") self.ax.grid(True, alpha=0.3) # Add colorbar for time norm = plt.Normalize(t.min(), t.max()) sm = plt.cm.ScalarMappable(cmap=self.cmap1, norm=norm) sm.set_array([]) cbar = plt.colorbar(sm, ax=self.ax) cbar.set_label('Time (s)') plt.tight_layout() plt.show() def plot_3d_surface(self): \"\"\"Create 3D surface plot of range vs v0 and theta\"\"\" fig = plt.figure(figsize=(16, 10)) ax = fig.add_subplot(111, projection='3d') # Generate data v0_values = np.linspace(10, 50, 30) theta_values = np.linspace(0, 90, 30) V0, THETA = np.meshgrid(v0_values, theta_values) R = np.zeros_like(V0) for i in tqdm(range(len(v0_values))): for j in range(len(theta_values)): R[j,i] = self.sim.calculate_range(V0[j,i], THETA[j,i]) # Plot surface with special effects surf = ax.plot_surface(V0, THETA, R, cmap=self.cmap2, rstride=1, cstride=1, alpha=0.8, edgecolor='none', shade=True) # Add contour projections ax.contourf(V0, THETA, R, zdir='z', offset=R.min(), cmap=self.cmap2, alpha=0.3) # Customize ax.set_title(\"Range as Function of Velocity and Angle\", fontsize=16, pad=20) ax.set_xlabel(\"Initial Velocity (m/s)\") ax.set_ylabel(\"Launch Angle (deg)\") ax.set_zlabel(\"Range (m)\") ax.view_init(elev=30, azim=45) # Add colorbar fig.colorbar(surf, shrink=0.5, aspect=10, label='Range (m)') plt.tight_layout() plt.show()","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_5","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-interactive-dashboard","text":"","title":"3. INTERACTIVE DASHBOARD"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_6","text":"class InteractiveDashboard: def init (self): self.vis = ProjectileVisualizer() self.setup_widgets() def setup_widgets(self): \"\"\"Create interactive controls\"\"\" self.v0_slider = FloatSlider( value=20, min=5, max=100, step=1, description='Initial Velocity (m/s):', style={'description_width': 'initial'}, continuous_update=False ) self.theta_slider = IntSlider( value=45, min=0, max=90, step=1, description='Launch Angle (deg):', style={'description_width': 'initial'} ) self.g_dropdown = Dropdown( options={'Earth (9.81 m/s\u00b2)': 9.81, 'Moon (1.62 m/s\u00b2)': 1.62, 'Mars (3.72 m/s\u00b2)': 3.72}, value=9.81, description='Gravity:', style={'description_width': 'initial'} ) self.drag_toggle = ToggleButtons( options=['No Drag', 'With Drag'], value='No Drag', description='Air Resistance:', style={'description_width': 'initial'} ) self.spin_slider = FloatSlider( value=0, min=-5000, max=5000, step=100, description='Spin (rpm):', style={'description_width': 'initial'}, disabled=True ) self.wind_slider = FloatSlider( value=0, min=-10, max=10, step=0.5, description='Wind Speed (m/s):', style={'description_width': 'initial'}, disabled=True ) # Link widgets def update_drag_options(change): self.spin_slider.disabled = change['new'] == 'No Drag' self.wind_slider.disabled = change['new'] == 'No Drag' self.drag_toggle.observe(update_drag_options, names='value') def launch(self): \"\"\"Start interactive dashboard\"\"\" interact_manual( self.vis.plot_trajectory, v0=self.v0_slider, theta=self.theta_slider, g=self.g_dropdown, drag=widgets.fixed(self.drag_toggle.value == 'With Drag'), spin=self.spin_slider, wind=self.wind_slider, planet=widgets.fixed('earth') )","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_7","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-machine-learning-optimization","text":"","title":"4. MACHINE LEARNING OPTIMIZATION"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_8","text":"class ProjectileOptimizer: def init (self): self.model = None self.train_model() def generate_training_data(self, n_samples=1000): \"\"\"Create dataset for ML model\"\"\" X = [] y = [] for _ in range(n_samples): v0 = random.uniform(5, 100) h0 = random.uniform(0, 50) g = random.uniform(1.62, 24.79) # Moon to Jupiter gravity # Find optimal angle numerically angles = np.linspace(0, 90, 91) ranges = [self.calculate_range(v0, a, g, h0) for a in angles] opt_angle = angles[np.argmax(ranges)] X.append([v0, h0, g]) y.append(opt_angle) return np.array(X), np.array(y) def train_model(self): \"\"\"Train Random Forest regressor\"\"\" X, y = self.generate_training_data() self.model = RandomForestRegressor(n_estimators=100) self.model.fit(X, y) def predict_optimal_angle(self, v0, h0, g): \"\"\"Predict optimal launch angle using ML\"\"\" return self.model.predict([[v0, h0, g]])[0]","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_9","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-main-execution","text":"","title":"5. MAIN EXECUTION"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_10","text":"if name == \" main \": print(\"\ud83d\ude80 Launching Ultimate Projectile Motion Simulator\") # Initialize components simulator = ProjectileSimulator() visualizer = ProjectileVisualizer() dashboard = InteractiveDashboard() optimizer = ProjectileOptimizer() # Example: Predict optimal angle for Mars conditions v0_example = 30 h0_example = 10 g_mars = 3.721 opt_angle = optimizer.predict_optimal_angle(v0_example, h0_example, g_mars) print(f\"\\n\u2728 ML Prediction: For v0={v0_example} m/s, h0={h0_example} m, g={g_mars} m/s\u00b2\") print(f\" Optimal launch angle = {opt_angle:.1f}\u00b0\") # Generate all visualizations print(\"\\n\ud83d\uddbc\ufe0f Generating visualizations...\") visualizer.plot_trajectory(v0=25, theta=45, g=9.81, drag=True, spin=2000) visualizer.plot_3d_surface() # Launch interactive dashboard print(\"\\n\ud83c\udfae Launching interactive dashboard...\") dashboard.launch() print(\"\\n\u2705 Simulation complete! Explore the interactive widgets above.\")","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_11","text":"","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-unit-tests-and-validation","text":"","title":"6. UNIT TESTS AND VALIDATION"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_12","text":"def run_tests(): \"\"\"Validate physics calculations\"\"\" print(\"\\n\ud83d\udd2c Running unit tests...\") # Basic projectile motion x, y, t = simulator.simulate_trajectory(20, 45) assert abs(x[-1] - 40.77) < 0.1, \"Basic range calculation failed\" # Zero gravity edge case x, y, t = simulator.simulate_trajectory(10, 45, g=1e-9) assert x[-1] > 1e6, \"Zero gravity behavior incorrect\" print(\"\u2705 All tests passed!\") run_tests()","title":"============================================="},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"}]}